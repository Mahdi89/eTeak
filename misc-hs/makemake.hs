import Language.Haskell.Syntax
import Language.Haskell.Parser
import Control.Monad
import Data.List
import System
import Maybe
import System.FilePath
import Misc

pickApartImport :: HsImportDecl -> String
pickApartImport (HsImportDecl _ (Module name) _ _ _) = name

findModuleDeps :: ParseResult HsModule -> Maybe (String, [String])
findModuleDeps (ParseOk (HsModule loc (Module moduleName) _exports imports _)) =
	Just (moduleName, map pickApartImport imports)
findModuleDeps parse = error $ show parse

main = do
	(binary:files) <- getArgs

	hFlags <- getEnv "HFLAGS"
	hLdFlags <- getEnv "HLDFLAGS"

	deps <- liftM catMaybes $ forM (sort files) $ \file -> do
		contents <- readFile file
		return $ findModuleDeps $ parseModule contents

	let
		modules = map fst deps
		sources = map (<.> "hs") modules
		objects = map (<.> "o") modules
		interfaces = map (<.> "hi") modules

	putStrLn "## Process this file with automake to produce Makefile.in"
	putStrLn "# Generated by teak makemake\n"

	putStrLn $ "bin_PROGRAMS = " ++ binary ++ "\n"

	putStrLn $ binary ++ "_SOURCES = " ++ joinWith " " sources ++ "\n"
	putStrLn $ "objects = " ++ joinWith " " objects ++ "\n"
	putStrLn $ "interfaces = " ++ joinWith " " interfaces ++ "\n"
	putStrLn $ "HFLAGS = " ++ hFlags ++ "\n"
	putStrLn $ "HLDFLAGS = " ++ hLdFlags ++ "\n"
	putStrLn $ binary ++ ": $(objects)"
	putStrLn "\t$(GHC) -o $@ $(HFLAGS) $(HLDFLAGS) $(objects)\n"

	putStrLn "SUFFIXES = .hs .o\n"
	putStrLn ".hs.o:"
	putStrLn "\t$(GHC) $(HFLAGS) -c $<\n"

	forM deps $ \(moduleName, imports) -> do
		-- my $flags = $flagss{$module}
		putStr $ moduleName ++ ".o: " ++ moduleName ++ ".hs "
		print imports
		print modules
		print $ intersect imports modules
		putStrLn $ joinWith " " (map (++ ".o") $ intersect imports modules) ++ "\n"

		{-
		for $import (@imports)
		{
			if (defined ($modules{$import}))
			{
				putStrLn " ", $import, ".o"
			}
		}
		if ($flags eq "")
		{
			putStrLn "\n"
		} else {
			putStrLn "\n\t$(GHC) $flags $(HFLAGS) -c $<\n"
		}
		-}

	putStrLn "CLEANFILES = $(objects) $(interfaces)\n"
